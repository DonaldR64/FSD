const CloseCombat = (msg) => {
    let Tag = msg.content.split(";");
    let attackerID = Tag[1];
    let defenderID = Tag[2];
    let attacker = UnitArray[attackerID];
    let defender = UnitArray[defenderID];
    let defenderStatus = "Passive";
    let defenderText = "Defender is a PASSIVE Defender";
    SetupCard("Close Combat","",attacker.faction);

    if (defender.token.get(SM.deactived) === true) {
        outputCard.body.push("Defender was Deactivated and so Destroyed");
        defenderStatus = "Destroyed";
    }
    if (defender.token.get(SM.immobilized) === true && (defender.type === "Vehicle" || defender.type === "Aircraft")) {
        outputCard.body.push("Defender " + defender.type + " was Immobilized and so Destroyed");
        defenderStatus = "Destroyed";
    }


    if (defenderStatus === "Destroyed") {
        PrintCard();
        defender.Destroyed();
        return;
    }


    //aircraft charging







    if (defender.token.get("aura1_color") === "#800080") {
        //is on guard
        defenderStatus = "Active";
        defenderText = "Defender is on Guard and is an ACTIVE Defender"
        if (defender.hexLabel !== defender.startHexLabel) {
            //defender countercharged
            defenderStatus = "Attacker";
            defenderText = "Defender Countercharges and is treated as an Attacker as well";
        }
        defender.token.set("aura1_color") === "#000000";
    } else {
        let defActions = parseInt(defender.token.get("bar1_value"));
        if (defActions > 0) {
            defenderText = "Defender Spends an Action to be ACTIVE Defender";
            defender.token.set("bar1_value",defActions - 1);
            defenderStatus = "Active";
        }
    }
    outputCard.body.push(defenderText);
    outputCard.body.push("[hr]");


    let acr = CombatRoll(attacker,defender,"Attacker");
    let attackCR = acr.cr;
    let atip = acr.tip;    
    let attackRollsInit = acr.rolls;
    let atarget = parseInt(defender.class) + parseInt(defender.armour);

    let dcr = CombatRoll(defender,attacker,defenderStatus);
    let defendCR = dcr.cr;
    let dtip = dcr.tip;
    let defenceRollsInit = dcr.rolls;
    let dtarget = parseInt(attacker.class) + parseInt(attacker.armour);


}




const CombatRoll = (unit1,unit2,combatStatus) => {
    let cr = parseInt(unit1.class)
    let crTip = "Base: " + cr + " C";
    //charging or countercharging
    if (combatStatus === "Attacker") {
        cr +=1;
        crTip += "<br>Charging +1 C"
        //gravity assisted here
        //
        //movement
        let move = HexMap[unit1.hexLabel].cube.distance(HexMap[unit1.startHexLabel].cube);
        let moveC = Math.floor(move/4);
        if (moveC > 0) {
            cr += moveC;
            crTip += "<br>" + move + " Hexes Movement +" + moveC + " C";
        }
        //LOS
        let defLOS = LOS(unit2,unit1);
        if (defLOS.los === false) {
            cr++;
            crTip += "<br>Outside Defenders LOS +1 C";
        }
        //walker or vehicle
        if (unit1.type === "Walker" || unit1.type === "Vehicle") {
            cr++;
            crTip += "<br>Unit is a " + unit1.type + " +1 C";
        }
        if (unit1.abilities.includes("Ramming")) {
            cr++;
            crTip += "<br>Unit has a Ramming Attachment +1 C";
        }
    }
    if (unit1.abilities.includes("Close Combat")) {
        cr++;
        crTip += "<br>Unit has a Close Combat Attachment +1 C";
    }
    if (unit2.abilities.includes("Shield")) {
        cr--;
        crTip += "<br>Opponent has a Shield -1 C";
    }
    if (unit1.type === "Aircraft") {
        cr--;
        crTip += "<br>Unit is an Aircraft -1 C";
    }
    if (unit1.type === "Walker" && unit1.token.get(SM.immobilized) === true) {
        cr--;
        crTip += "<br>Unit is an Immobilized Walker -1 C";
    }

    let rolls = [];
    for (let i=0;i<cr;i++) {
        let roll = randomInteger(12);
        rolls.push(roll);
    }
    rolls.sort((a,b) => b - a);
    
    let info = {
        cr: cr,
        tip: crTip,
        rolls: rolls,
    }
    
    return info;
}




